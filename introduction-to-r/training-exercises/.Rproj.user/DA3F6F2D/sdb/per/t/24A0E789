{
    "contents" : "---\ntitle: \"Introduction to R: Core Language Tutorial\"\nauthor: \"Dr Jeromy Anglim\"\noutput: pdf_document\n---\n\n\n```{r load_project, message = FALSE, warning = FALSE}\nlibrary(ProjectTemplate); load.project()\n```             \n\n\n\n# Basic Arithmetic and Logical Operations\n```{r basic_multiplication}\n# You can use R like a calculator\n1 + 1 # addition\n10 - 9 # subtraction\n10 * 10 # multiplcation\n100 / 10 # division\n10 ^ 2 # exponentiation\n\nabs(-10) # absolute value\nceiling(3.5) # round up to next integer\nfloor(3.5) # round down to next integer\nsqrt(100) # square roots\nexp(2) # exponents\npi # mathematical constant pi\nexp(1) # mathematical constant e\nlog(100) # natural logs (i.e., base e)\nlog(100, base= 10) # base 10 logs\n\n\n# Use parentheses to clarify order of operations\n(1 + 1 ) * 2\n1 + (1 * 2)\n\n# You can test for equality\n# TRUE and FALSE are keywords\n# T and F are synonyms, but are generally discouraged\nTRUE\nFALSE\n1 == 2 # Equality (Return TRUE if equal)\n1 != 2 # Inequality (Return FALSE if unequal)\n10 > 9 # Greater than\n9 < 10 # Less than\n10 <= 10 # Less than or equal\n2 %in% c(1, 2 ,3) # is the number in the vector\n\n# TRUE and FALSE coerces to 1 and 0 respectively\nas.numeric(TRUE)\nas.numeric(FALSE)\n\n# Logical converting to 0, 1 is useful\nx <- c(2, 5 ,7 ,10, 15)\nx > 5\nsum(x > 5)  # sum of a 0-1 variable is a count\nmean(x > 5) # mean of a 0-1 variable is a proportion\n```\n\n\n\n# Basic language features\n```{r basic language features, error = TRUE}\n########################################################\n# Assignment:\n# To assign values to a variable either use <- or =\n# <- is the more common convention in R\nx <- 1 + 1\nx\n\n# = is the common assignment operator in other programming \n# languages. It does work in R, but is not the convention.\ny = 1 + 1\ny\n\n########################################################\n# Variable name rules:\n# Variable names generally\n# 1. Start with a letter (lower or uppercase)\n# 2. Followed by letters, numbers, underscore (_), or period (.)\n# 3. No spaces\n\n# These do not work\n# my variable <- 1234\n# 1234variable <- 1234\n# 1234 <- 1234\n\n# This works\nmyvariable <- 1234\nmy_variable <- 1234\nmy_variable <- 1234\nmyvariable123 <- 1234\nmyVariable <- 1234\nmy.variable <- 1234\n\n# R has many naming conventions\n# As a matter of preference, style, and convenience, I prefer:\n# 1. Short but descriptive names\n#    * Less than 8 characters for names of lists and data.frames\n#    * Less than 15 characters for variables names in data.frames\n# 2. Use underscore to separate words within a variable name\n# 3. Avoid upper case letters\n\n# Names starting with a period are hidden\n.myvariable <- 1234\nls()\nls(all.names = TRUE)\n\n\n########################################################\n# Comments:\n# Comments are any text on a line following a hash #\n# 1. They often appear as the first character of a line\n#    to present a whole line comment\n# 2. At the end of a common on a line\nmean(c(1,2,3,4)) # Example of end of line comment\n\n# 3. Half way through a command at the end of a line\nc(1, # Example comment\n  2,3,   # Another comment\n  4)\n  \n\n########################################################\n# Spaces: \n# R will generally permits zero, one or more spaces between\n# variables, operators, and other syntactic elements. \n# However, appropriate and consistent spacing improves\n# the readability of you scripts.\n# See Hadley Wickham's style guide:\n# http://adv-r.had.co.nz/Style.html\n\n# This is bad but works\nx<-c(1,2,3,400)*2\nx<-    c (   1,2,3,      400)*   2\n\n# This is more readable:\n# Add spaces after variables, operators, commas\nx <- c(1, 2, 3, 400) * 2\n\n\n######################################################\n# Multipline line commands\n# Commands can generally span multiple lines\n# as long as R does not think the command has finished \n\n# This works\nx <- c(\"apple\", \n       \"banana\") \nx\ny <- 10 + \n    10  #this works\ny\n\n# This does not work\ny <- 10\n    + 10 \ny\n\n\n########################################################\n# Multiple commands on one line\n# You can include more than one command on one line \n# by separat the commands by a semicolon.\n# But generally, you should avoid doing this as it is not\n# very readable.\nx <- c(1, 2); y  <- c(3, 4); z <- rnorm(10)\nx;y;z\n\n\n########################################################\n# # R is case sensitive\ntest <- \"lower case\"\nTEST <- \"upper case\"\nTEST \ntest # The original value was not lost\n     # because test is different to TEST\nTest # This variable does not exist\n\nTest <- \"title case\"\nTest\n\n\n# tip: It's often simpler to make variables lower case\n#      so that you don't have to think about case.\n```\n\n\n# Understanding directories\n```{r directories}\n# R has a working directory.\n# This is important when loading and saving files to disk\ngetwd() # show the current working directory\n\n# you can use setwd to change the working directory\n# setwd(\"~/blah/myproject\")\n\n# Tip: Open RStudio with the Rproj file then the working directory\n# will be the directory containing the Rproj file.\n\n# Tips: \n# * Try to avoid spaces in file names \n#   (use hyphen or underscore instead)\n# * If on Windows, then disable \"hide extensions of \n#   known file types\" (see folder options )\n# * If you do use spaces, then you'll need to escape the space with\n#   a slash  (e.g., (\"my\\ documents\")\n# * Use backslash as the directory separator \n# * Store all relevant files for a project within \n#   the project working directory\n```\n\n# The Workspace\n```{r workspace}\n###############################################\n# R Sessions:\n\n# Quitting R\n# You can end the R Session using the q function\n# q() \n\n# But if you are in Rstudio, it is simpler to:\n# * Just quit RStudio and this will quit the R session\n# * Use the session menu in RStudio to Restart or Terminate\n#   an R session\n\n\n################################################\n# Workspaces and environments:\n# list environments \nsearch()\n\n# Create some objects in the global environment\nx <- 1:10\ny <- 1:20\ndata(mtcars) # Add a built-in datset mtcars\n\n# Show objects in the global environment\nls() \n\n# or look at the environment pane in RStudio\n\n###############################################\n# Removing objects:\n# Removing named objects with the rm function\nrm(x)\nls()\nrm(y, mtcars)\n\n# Remove all objects from global workspace\n# Option 1. Use the following command\nrm(list = ls())\n# Option 2. Click the broom object in RStudio Environment pane\n\n##############################################\n# Saving objects\n# Save all objects in the workspace\nsave.image() \n\nx <- 30\ny <- 1:10\n# Save specific named objects using save function.\n# rdata or RData is the standard file exetnsion.\nsave(x, y, file = \"output/y.rdata\") \n\n# Let's remove x and change y\nrm(x) \ny <- \"changed\"\ny\n\n# load variables stored in rdata file \nload(file = \"output/y.rdata\")\nx\ny\n\n# Tips: \n# * Try to avoid using save.image() to store temporary calculations\n# * Instead, try to write scripts that can be run to return you to \n#   your current state of analyses.\n```\n\n \n# Data types: Logical, character, numeric\n```{r data types}\n#######################################################\n# Basic data types\n# The most common basic vector types are\nx <- c(FALSE, TRUE) # logical vector\ny <- c(\"a\", \"b\", \"cat\", \"dog\") # character vector\nz1 <- c(100, 1, 2, 3) # numeric integer vector\nz2 <- c(100.2, 0.4, 0.9) # numeric real/double vector\nclass(x);  typeof(x); mode(x)\nclass(y);  typeof(y); mode(y)\nclass(z1);  typeof(z1); mode(z1)\nclass(z2);  typeof(z2); mode(z2)\n\n# Checking type of object\n# there are a range of \"is.\" functions for that return TRUE\n# if object is of corresponding type\n# apropos(\"^is\\\\.\")\nis.logical(c(TRUE, TRUE))\nis.numeric(c(\"a\", \"b\"))\nis.character(c(1, 2, 3))\n\n#############################################################\n# Conversion of Types:\n# R has functions that explicitly convert data types\n# apropos(\"^as\\\\.\")\nas.character(c(1, 2, 3, 4))\nas.numeric(c(\"1\", \"2a\", \"3\", \"four\"))\nas.numeric(c(FALSE, FALSE, TRUE, TRUE))\n\n# R often performs conversions implicitly\nsum(c(FALSE, TRUE, TRUE)) # converts logical to 0, 1 numeric\npaste0(\"v\", c(1, 2, 3)) # converts numeric vector to character\n```\n\n# Basic data structures: Vectors, Matrices, Lists, Data.frames\n```{r basic data structures}\n###########################################################\n# Vectors:\n# In R, a single value (scalar) is a vector.\nx <- 1 # I.e., x is a vector of length 1\n\n\n# In addition to importing data,\n# R has various functions for creating vectors.\nc(1, 2, 3, 4) # c stands for combine\n1:10 # create an integer sequence 1 to 10\nseq(1, 10) # alternative way of creating a sequence \nseq(1, 10, by = 2) # The function has additional options\nrep(1, 5) # repeat a value a certain number of times\nrep(c(1,2,3), 5) # repeat a value a certain number of times\n\n# as well as many simulation functions which we'll cover later\n# Initial examples:\n# Sample 10 items with replacement from \nsample(x = c(\"happy\", \"funny\", \"silly\"), size = 10, replace = TRUE)\n\n# Sample 20 values from a normal distribution\ny <- rnorm(n = 20, mean = 0, sd = 1) \nhist(y) # show values in histogram\n\n\n# Vectors can have names\nx <- c(1,2,3,4,5)\nnames(x) <- c(\"a\", \"b\", \"c\", \"d\", \"e\")\nx\n\n# Extracting vectors\nx[c(1,2)] # by numeric position\nx[x < 3] # by logical vector\nx[c(\"b\", \"c\")] # by name\n\n\n\n\n###########################################################\n# Matrices:\n# All data must be of same type (e.g., numeric, character, logical)\ny <- matrix(c(1, 2, \n             4, 5, \n             7, 8 ),\n           byrow = TRUE, ncol = 2)\ny\n\nclass(y)\n\n# number of rows and columns\ndim(y)  # Number of rows and columns\nnrow(y) # Number of rows\nncol(y) # Number of columns\n\n# Rows and columns can be given names\nrownames(y) <- c(\"a\", \"b\", \"c\")\ncolnames(y) <- c(\"col1\", \"col2\")\n\n# Rows and columns can be indexed\ny[\"a\", ] # By rowname\ny[, \"col1\"] # By column name \ny[\"a\", \"col1\"] # By both\n\ny[c(1,2), ] # By row position\ny[,1] # By column position\ny[c(2,3), 2] # By column position\n\n###########################################################\n# Lists\n# Store arbitrary structures of one or more named elements.\n# Elements can be of different lengths\n# Lists can contain lists can be nested to create tree like structures\n# Lists are commonly used for representing results of analyses\n\nw <- list(apple = c(\"a\", \"b\", \"c\"), \n          banana = c(1,2), \n          carrot = FALSE,\n          animals = list(dog = c(\"dog1\", \"dog2\"), \n                         cat = c(TRUE, FALSE)))\n\nclass(w)\n\n# Accessing one element of list\nw$apple # using dollar notation\nw[[1]] # by position\nw[[\"apple\"]] # by name (double brackets)\n\n# Accessing subset of list\nw[c(1, 2)]  # by position (single bracket)\nw[c(\"apple\", \"banana\")] # by name\nw[c(FALSE, FALSE, TRUE, TRUE)] # by logical vector\n\n# Quick illustration of a list object returned by\n# a statistical function\n\n# We'll simulate some data for two hypothetical groups x and y\n# and perform an independent samples t-test.\nx <- rnorm(10, mean = 0, sd = 1) \ny <- rnorm(10, mean = 1, sd = 1)\nfit <- t.test(x, y)  \n\n# The function \nclass(fit) # class does not say list, but it is a list\nmode(fit)\nstr(fit) # show structure of object\nnames(fit) # show names of elements\n# we can view particular elements\nfit$statistic \nfit$parameter\nfit$p.value\n# or extract subsets of the list\nfit[c(\"statistic\", \"parameter\", \"p.value\")]\n\n\n###########################################################\n# Data Frames:\n# Data frames are the standard data strucure used for storing\n# data. If you have used other software (e.g., SPSS, Excel, etc.), \n# this is what you may think of as a \"dataset\".\n# Columns can be of different data types (e.g., character, numeric, logical, etc.)\nz <- data.frame(var1 = 1:9, var2 = letters[1:9])\nz\n\n# Tip: Some functions work with matrices, \n#   some work with data.frames, \n#   and some work with both.\n# * If you are wanting to store data like you might store in \n#   a database, then you'll generaly want a data.frame.\n# * If you are dealing with a mathematical object that you\n#   you want to perform a mathematical operation on, then you generally\n#   want a matrix (e.g., correlation matrix, covariance matrix, \n#   distance matrix in MDS, matrices used for matrix algebra).\n```\n\n\n\n\n\n# Working with data frames\n```{r exploring data frames}\n# Let's use the built-in survey data.frame dataset\nlibrary(MASS)\ndata(survey)\n?survey\nmydata <- na.omit(survey) # for simplicity I'll exclude missing data\nshortdata <- mydata[1:6, 1:5] \nshortdata\n\n################################################\n# Extracting observations (i.e., rows) and \n# variables (i.e., columns).\n# There are similarities to matrices and lists\n# Select observations\nshortdata[1:5, ] # by row number\nshortdata[c(5,4,3,2,1), ] # re-order\nshortdata[ shortdata$Sex == \"Female\", ] # by logical vector\nshortdata[c(\"1\", \"2\"), ] # by rownames\n\n# Select variables \nshortdata[, c(1,2)] # by position like a matrix\nshortdata[c(1,2)] # by position like a list\nshortdata[ ,c(\"Sex\", \"Fold\")] # by name like a matrix\nshortdata[c(\"Sex\", \"Fold\")] #\nshortdata$Sex # by name to get a single variable\n\n\n#################################################\n# Names\nnames(shortdata) # get variable names\ncolnames(shortdata) # but this also works\nrownames(shortdata) # rows can also have names\n\n# Tip: Avoid row names.\n# Add another variable to the data.frame to store this information.\n\n\n# Examine first few rows\nhead(mydata) # first 6 rows\nhead(mydata, n = 10) # first 7 rows\ntail(mydata) # last few rows\n# View(mydata) # Rstudio function to open data in viewer\n# or click on the icon in the Environment pane\n\n# How many rows and columns?\ndim(mydata) # rows and column counts\nnrow(mydata) # row count\nncol(mydata) # column count\n\n# Examine structure\nstr(mydata)\n```\n\n# Getting help\n```{r getting help}\n# Use question mark (i.e., ?) followed by command name\n# to lookup specific command\n?mean \nhelp(mean) # or use help function\n\n# to look up package\nhelp(package = \"MASS\")\n\n# Press F1 in RStudio on the command name\n# mean \n\n# Use double question mark to do a full-text search on R help\n??\"factor analysis\"\n\n# Search google\n# e.g., how to get the mean of a vector using r\n\n# Ask question on Stackoverflow with the R tag\n# http://stackoverflow.com/questions/tagged/r\n```\n\n# Exercise 1 \n```{r Exercises 1}\n# 1. Working with vectors\n# 1.1 Create a variable called x with 10 values drawn from a \n#    normal distribution (see rnorm)\n\n# 1.2 Use the sum and > operator to work out how many values in x\n#    are larger than 1\n\n\n# 3. Using the cats dataset in the MASS package\nlibrary(MASS)\ndata(cats)\n# 3.1 Look up the help file on cats\n\n# 3.2 How many observations are there?\n\n# 3.3 Show the first 10 rows of the cats data.frame\n\n# 3.4 Show the structure of cats using the str function\n\n# 3.5 Extract the female cats and assign to variable fcats\n\n# 3.6 How many rows is in fcats?\n\n```\n\n# Answers 1\n```{r Answers for Exercises 1}\n# 1. Working with vectors\n# 1.1 Create a variable called x with 10 values drawn from a \n#    normal distribution (see rnorm)\nx <- rnorm(10)\n\n# 1.2 Use the sum and > operator to work out how many values in x\n#    are larger than 1\nsum(x > 1)\n\n# 3. Using the cats dataset in the MASS package\nlibrary(MASS)\ndata(cats)\n# 3.1 Look up the help file on cats\n?cats\n\n# 3.2 How many observations are there?\nnrow(cats)\n\n# 3.3 Show the first 10 rows of the cats data.frame\nhead(cats, 10)\n\n# 3.4 Show the structure of cats using the str function\nstr(cats)\n\n# 3.5 Extract the female cats and assign to variable fcats\nfcats <- cats[ cats$Sex == \"F\", ]\n\n# 3.6 How many rows is in fcats?\nnrow(fcats)\n\n```\n\n\n\n\n# Packages\n```{r packages, error = TRUE}\n# R has many additional packages \n# To use a package it needs to be installed. \n# You only need to install a package once.\n# To use a package, you need to load the package each time\n# you use R.\n\n\n##############################################################\n# Installation\n# Option 1. Use the install.packages function.\n# install.packages(\"psych\")\n# Note that some packages rely on other packages.\n# depencies = TRUE ensures that dependencies are also installed.\n# install.packages(\"psych\", dependencies = TRUE)\n\n# Option 2. Use the package tab in R Studio\n# Click install and enter package details\n\n\n\n\n\n##############################################################\n# Loading an installed package\n# Option 1. Use the library function\nlibrary(psych) # I.e., put this at the start of your script\n\n# Other options \n# 2. We'll talk about ProjectTemplate later\n#\n# 3. Put it in your R startup file \n#    (not recommended as it reduces reproducibility)\n\n##############################################################\n# Common errors\n# Not having a package installed is a common error\n# If you try to load a package that is not installed.\n# e.g., \nlibrary(foo)\n# You will get an error\n# Error in library(foo) : there is no package called ‘foo’\n# This means:\n# 1. You mistyped the name of the package, or\n# 2. You need to install the pakcage\n#     install.packages(\"foo\")\n# Note foo is just an example. There is no package called foo.\n\n# Not having a package loaded is a common error\n# E.g., there is a function you want to use\ndetach(package:psych) # used for example to ensure psych is not attached \n# say we wanted to use the fisherz function from the psych package\n# but the psych package is not loaded\nfisherz(.3)\n# We get the error:\n#   \"Error: object 'fisherz' not found\"\n# Thus we need to run\nlibrary(psych)\nfisherz(.3)\n\n\n##############################################################\n# Packages contain additional functions.\n# Once the package is loaded, functions are added to the workspace\n# list workspace\nsearch()\n\n# To make it clear that a function comes from a particular package\n# or to overcome the issue where two packages have functions with the same names\n# use double colon (i.e., package::function).\n# RStudio also permits auto-completion of function names.\n# psych::alpha() # alpha is a funtion in the psych package\n\n```\n\n\n\n# Missing data\n```{r missing data}\n# Missing data is represented in R by NA\nx <- c(1, 2, NA, 4)\ny <- c(\"a\", \"b\", NA, \"c\")\nx\ny\n\n# To see whether a value is missing\nis.na(x)\n\n# If you have missing data, some functions will return NA by default\n# rather than returning a value\nmean(x)\nsd(x)\n\n# Many functions have a na.rm argument\nmean(x, na.rm=TRUE)\nsd(x, na.rm=TRUE)\n\n# or you remove the missing data\nna.omit(x)\nmean(na.omit(x))\n\n# na.omit also works on data frames performing listwise deletion\nhead(survey)\ndim(survey)\ncleaned_survey <-na.omit(survey)\ndim(cleaned_survey)\n```\n\n# Getting summaries of data frames\n```{r data.frame summaries, warning = FALSE}\nlibrary(MASS) # user survey data from MASS package\ndata(survey) # load an internal dataset\nmydata <- survey\n\n# Variable Names\nnames(mydata)\n\n# Show structure\nstr(mydata)\n\n# Useful summary of numeric and categorical variables\nHmisc::describe(mydata)\n\n# Common univariate statistics for numeric variables\npsych::describe(mydata)\nsummary(mydata)\n```\n\n# Summaries of numeric vectors (or data frame variables)\n```{r summaries of numeric vectors}\nx <- c(1, 2, 3, 4,5)\n\n# Total\nsum(x) # sum of vector\nprod(x) # product of vector\n\n# Central tendency\nmean(x) # mean of vector\nmedian(x) # median of vector\nlength(x) # length of vector\n\n# Spread\nsd(x) # standard deviation\nvar(x) # variance\nrange(x) # min and max of vector\nmin(x) # minimum of vector\nmax(x) # max of vector\n\n# Other distributional features\npsych::skew(x) # skewness \npsych::kurtosi(x) # kurtosis\n```\n\n```{r vector operations}\ndat <- data.frame(x = c(1, 2, 3, 4, 5), \n                  y = c(0, 0, 1, 1, 1))\ndat\n\n# Vector operations typically operate element wise\ndat$z <-  dat$x + dat$y\ndat\n\ndat$z <-  dat$x * dat$y\ndat\n\n# A single value is recyled through the vector\ndat$z <- dat$x + 10\ndat\n```\n\n# Exercise 2 - Data.frames\n```{r exercise 2}\n# For this exercise will use the GSS7402 dataset\nlibrary(AER)\nhelp(package = AER)\ndata(\"GSS7402\")\n?GSS7402 # to learn about the dataset\n# It might be easier to work with a shorter variable name \ngss <- GSS7402\n\n# 1. List the variable names in the gss dataset\n\n# 2. Show the first few rows (hint: the head) of the dataset?\n\n# 3. How many cases are there?\n\n# 4. What is the mean, sd, and range age of the sample\n\n# 5. Use the psych and Hmisc describe functions to describe the samples\n\n# 6. Extract a data.frame with only people over the age of 80\n\n# 7. Get the mean number of children (\"kids\") for participants \n#    over the age of 80\n\n# 8. Use the mean function to get the mean age at first birth.\n#    Hint: there is missing data.\n```\n\n\n# Answers Exercise 2 - Data.frames\n```{r answers for exercise 2, warning = FALSE}\n# For this exercise will use the GSS7402 dataset\nlibrary(AER)\nhelp(package = AER)\ndata(\"GSS7402\")\n?GSS7402 # to learn about the dataset\n# It might be easier to work with a shorter variable name \ngss <- GSS7402\n\n# 1. List the variable names in the gss dataset\nnames(gss)\n\n# 2. Show the first few rows (hint: the head) of the dataset?\nhead(gss)\n\n# 3. How many cases are there?\nnrow(gss)\n\n# 4. What is the mean, sd, and range age of the sample\nmean(gss$age)\nsd(gss$age)\nrange(gss$age)\n\n# 5. Use the psych and Hmisc describe functions to describe the samples\npsych::describe(gss)\nHmisc::describe(gss)\n\n# 6. Extract a data.frame with only people over the age of 80\ngss_over80 <- gss[ gss$age > 80, ]\n\n\n# 7. Get the mean number of children (\"kids\") for participants \n#    over the age of 80\nmean(gss[ gss$age > 80, \"kids\"])\n\n# 8. Use the mean function to get the mean age at first birth.\n#    Hint: there is missing data.\nmean(gss$agefirstbirth) # doesn't work because there is missing data\nmean(gss$agefirstbirth, na.rm = TRUE) # doesn't work because there is missing data\n```\n\n\n# String functions\n```{r string functions}\npaste(\"hello\", \"how\", \"are\", \"You\") # defaults to space separator\npaste0(\"hello\", \"how\", \"are\", \"You\") # no separator\npaste(\"apple\", \"banana\", \"carrot\", \"date\", sep =\", \") # specify arbitrary separator\npaste0(\"v\", 1:10) # paticularly useful with vectors\n\n# Extract substring\nsubstr(\"abcdefghijklmnop\", 4, 6)\n\n# Change case\ntoupper(\"abcd\") # make upper case\ntolower(\"ABCD\") # make lower case\n\nmystring <- c(\"apple\", \"banana\", \"carrot\", \"date\", \"egg\", \"fig\")\n# Identify which strings match a pattern\ngrep(\"a\", mystring) # index of objects with \"a\"\ngrep(\"a\", mystring, value = TRUE) # value of objects with \"a\"\n\n# get count of number of characters\nnchar(mystring)\ndata.frame(mystring, nchar(mystring))\n\n# Substitute a mystringreplacement text that matches a pattern\nquestions <- c(\"How are you?\", \"What is going on?\")\ngsub(\" \", \"_\", questions) # replace space with underscore\n\n\n# R  string manipulation tools are very powerful\n# For more information see\n?grep\n?\"regular expression\"\n\n\n# see also Hadley Wickham's package for string manipulation\n# It attempts to introduce greater consistency in notation.\n# install.packages(\"stringr\")\nlibrary(stringr)\nhelp(package = \"stringr\")\n# all functions begin with str_\nstr_length(mystring) # see nchar\nstr_sub(mystring, start = 1, end = 3)\n\n\n# writing output to the console\ncat(\"Hello World!\")\n\n# Tab is \\t and new line is \\n\ncat(\"Hello\\t World\\nSome more text\")\n\n```\n\n\n# Importing data\n```{r reading data}\n# A simple option is to export data from your external data\n# in csv format and then import the data using csv\n# csv\nmedals <- read.csv(\"data/practice/medals.csv\")\nhead(medals)\ntail(medals)\ndim(medals)\n\n# Other delimited formats\nmedals <- read.table(\"data/practice/medals.tsv\", sep =\"\\t\")\n\n# Read Excel: \n# Read xls files using xls\n# Requires that Perl is installed and on the path\n# You may need to install Perl if on Windows\n# https://www.perl.org/get.html\n# library(gdata) \n# medals <- gdata::read.xls(\"data/practice/medals.xls\")\n\n# requires Java\n# library(xlsx)\n# x <- xlsx::read.xlsx(\"data/practice/medals.xlsx\", sheetIndex = 1)\n\n# More recent package that has no dependencies on external packages \n# readxl\nlibrary(readxl)\nmedals <- readxl::read_excel(\"data/practice/medals.xls\")\nmedals <- readxl::read_excel(\"data/practice/medals.xlsx\")\n\n\n# SPSS\nlibrary(foreign)\ncas <- foreign::read.spss(\"data/practice/cas.sav\", to.data.frame = TRUE)\nattr(cas, \"variable.labels\")\n# tip: You may need to think about value labels in your SPSS file\n# Specifically, if you have numeric variables that have variable labels, you may\n# want to remove the value labels in SPSS or \n\n# import stata\n?read.dta\n?read.sas\n\n\n# General purpose packages \n# The haven package also can read and write SPSS, SAS, and Stata files\n\n# rio package: General purpose import and export\n# General purpose import and export tools\n# It's a fairly new package so there may still be a few bugs.\n# https://github.com/leeper/rio\n# github version is currently a little bit ahead of the CRAN version\nlibrary(rio)\ncas <- rio::import(file=\"data/practice/cas.sav\")\nrio::export(cas, file=\"output/cas.xlsx\")\nmedals <- rio::import(file=\"data/practice/medals.csv\")\n\n# Use ProjectTemplate to auto-import (see discussion later)\n```\n\n# Exporting data \n```{r exporting data}\nmydata <- data.frame(a = c(1,2,3), b = c(\"a\", \"b\", \"c\"))\n\n# Interal R format\n# Good option if you need to re-open data in R\nsave(mydata, file=\"output/mydata.rdata\")\n#  load(\"output/mydata.rdata\")\n\n\n# csv\n# Good option if you need to get data into other software\n# This should open in almost all other software (e.g. Excel, SPSS, etc.)\nwrite.csv(mydata, file = \"output/mydata.csv\")\nwrite.csv(mydata, file = \"output/mydata-2.csv\", row.names = FALSE) # exclude row.names\n\n# If you need more flexibility in terms of delimiters, etc.\nwrite.table(mydata, file = \"output/mydata.tsv\", sep = \"\\t\") # e.g., tab delimiter\n\n# Exporting to other formats\n# There are a range of options for exporting to other formats\n# Functionality is often spread around\n# Given that the csv option is usually sufficient\nlibrary(foreign)\n?foreign::write.foreign  # options for exporting to SAS, SPSS, and Stata directly\n\n?rio::export\n```\n\n# Exercise 3\n```{r Exercise 3}\n# 1. Open medals.csv in the data/practice/ directory \n#    and assign to variable medals\n\n# 2. Check that the file imported correctled\n#    (a) look at the first few rows, \n#    (b) look at the last few rows,\n#    (b) check the structure (i.e., str),\n#    (c) Use the Hmisc describe function to check basic properties\n\n# 3. Create a new variable in medals that indicates\n#    whether the medals was Gold (TRUE) or Silver/Bronze (FALSE)\n#    and call it isgold\n\n# 4. How the number of sum of gold medals \n\n# 5. Export the medals data.frame to the output folder\n#    (a) as a csv file\n#    (b) as a native rdata file\n\n# 6. Remove the medals dataset from the workspace \n#    and then load it again from the csv file.\n#    Check that it imported correctly. \n# Then remove medals and repeat for the rdata file\n\n```\n\n# Answers for Exercise 3\n```{r Answers for Exercise 3}\n# 1. Open medals.csv in the data/practice/ directory \n#    and assign to variable medals\nmedals <- read.csv(\"data/practice/medals.csv\")\n\n# 2. Check that the file imported correctled\n#    (a) look at the first few rows, \n#    (b) look at the last few rows,\n#    (b) check the structure (i.e., str),\n#    (c) Use the Hmisc describe function to check basic properties\nhead(medals)\ntail(medals)\nstr(medals)\nHmisc::describe(medals)\n\n# 3. Create a new variable in medals that indicates\n#    whether the medals was Gold (TRUE) or Silver/Bronze (FALSE)\n#    and call it isgold\nmedals$isgold <- medals$Medal == \"Gold\"\n\n# 4. How the number of sum of gold medals \nsum(medals$isgold)\n\n# 5. Export the medals data.frame to the output folder\n#    (a) as a csv file\n#    (b) as a native rdata file\nwrite.csv(medals, \"output/medals.csv\")\n# or technically you may want to do\nwrite.csv(medals, \"output/medals.csv\", row.names = FALSE)\nsave(medals, file = \"output/medals.rdata\")\n\n# 6. Remove the medals dataset from the workspace \n#    and then load it again from the csv file.\n#    Check that it imported correctly. \n# Then remove medals and repeat for the rdata file\nrm(medals)\nmedals <- read.csv(\"output/medals.csv\")\nhead(medals)\n\nrm(medals)\nload(\"output/medals.rdata\")\nhead(medals)\n```\n\n\n# Random variables and distributions\n```{r random variables and distributions}\n# In statistics, we often want to generate random data with certain properties\n# or looking up features of statistical distributions.\n# See the following help for list of common distributions is base R\n?Distributions\n\n# and see http://cran.r-project.org/web/views/Distributions.html for many more distributions\n\n# Each distribution has four functions that differ in terms of the first letter\n# For example, for the normal distribution, you have\ndnorm(1) # Density of the value 1 of a standard normal distribution\npnorm(1) # Cumulative distribution function for value of 1 on standard normal distribution\nqnorm(.975) # Inverse cumulative distribution function for value of .975\nrnorm(5) # Generate 5 random draws from normal distribution\n\n# \ndunif(1) # Density of the value 1 of a uniform distribution (0, 1)\npunif(.5) # Cumulative distribution function for value of 1 on uniform distribution\nqunif(.975) # Inverse cumulative distribution function for value of .975\nrunif(5) # Generate 5 random draws from uniform distribution\n\n\n# Distributions have parameters that can be specified\nx <- rnorm(10, mean = 10, sd = 1) # draw 10 from mean of 10\ny <- rnorm(10, mean = 11, sd = 1) # draw 10 from mean of 11\ndat <- data.frame(x=x, y=y)\ndat\nboxplot(dat)\n```\n\n\n# Functions\n```{r functions}\n# You can write functions and these are generally the same as\n# the functions you use in R\n\n# For example, I could create a function that printed some text\nprint_some_text <- function(x = \"Hello World\") {\n    print(x)\n}\n\n# If I run the above command, I can then use it\nprint_some_text() # using the default argument\nprint_some_text(\"blah blah blah\")  # or to print some other text\n\n# Anatomy of a function \n# Functions have a name\n# They take one or more arguments\n# Arguments may have default values\n\n\n# Let's take a more interesting example: Power analysis\n# The following data simulates data for two groups and\n# examines whether there is a significant difference at .05\n# It repeats the process 1000 times and calculates the\n# proportion of times it is statistically significant\n# (i.e., simluation estimate of the statistical power)\n\nsignificant <- NULL\nfor (i in 1:1000) {\n    x <- rnorm(30, mean = 0.0, sd = 1) \n    y <- rnorm(30, mean = 0.3, sd = 1) \n    fit <- t.test(x, y)\n    fit\n    significant[i] <- (fit$p.value < .05)\n}\nstatistical_power <- mean(significant)\nstatistical_power\n\n# we could convert this to a function\npower_group_dif1 <- function() {\n    significant <- NULL\n    for (i in 1:1000) {\n        x <- rnorm(30, mean = 0.0, sd = 1) \n        y <- rnorm(30, mean = 0.3, sd = 1) \n        fit <- t.test(x, y)\n        fit\n        significant[i] <- (fit$p.value < .05)\n    }\n    statistical_power <- mean(significant)\n    statistical_power\n}\n\npower_group_dif1()\n\n# but the beauty of function is that they can make things general\n# Let's make the mean of group 2 an argument that can be specified\npower_group_dif2 <- function(mean2 = 0.3) {\n    significant <- NULL\n    for (i in 1:1000) {\n        x <- rnorm(30, mean = 0.0, sd = 1)\n        y <- rnorm(30, mean = mean2, sd = 1) \n        fit <- t.test(x, y)\n        fit\n        significant[i] <- (fit$p.value < .05)\n    }\n    statistical_power <- mean(significant)\n    statistical_power\n}\n\n# now we can specify different values\npower_group_dif2(0) \npower_group_dif2(.3) \npower_group_dif2(.5) \npower_group_dif2(.8) \npower_group_dif2(1) \n\nsettings <- seq(from = 0, to = 2, by = .1)\nresults <- data.frame(mean2= settings)\nresults$power <- sapply(results$mean2, function(X) power_group_dif2(X))\nplot(results, type = \"b\")\n\n\n# obviously it could be made a whole lot more general\npower_group_dif3 <- function(mean1 = 0, mean2 = 0.3, sd1 = 1, sd2 = 1, \n                             n1 = 30 , n2 = 30, ksimulations = 1000,\n                             alpha_criterion = .05) {\n    significant <- NULL\n    for (i in 1:ksimulations) {\n        x <- rnorm(30, mean = mean1, sd = sd1)\n        y <- rnorm(30, mean = mean2, sd = sd2) \n        fit <- t.test(x, y)\n        fit\n        significant[i] <- (fit$p.value < alpha_criterion)\n    }\n    statistical_power <- mean(significant)\n    statistical_power\n}\n\npower_group_dif3(mean1 = 10, mean2 = 11, sd1 = 1, sd2 = 1, \n                             n1 = 100 , n2 = 100, ksimulations = 1000,\n                             alpha_criterion = .01)\n\n```\n\n# Debugging functions\n```{r debugging functions}\n# debugging functions\nprint_some_text <- function(x = \"Hello World\") {\n    print(x)\n}\ndebugonce(print_some_text) # activates debugging on the function\nprint_some_text()\n\n# many other useful functions\n?traceback # provide further information when an error occurs\n?browser # place in function \n```\n\n\n# Viewing source code for internal functions\n```{r viewing source code, error = TRUE, results = \"hide\"}\n# Option 1: type function name\nt.test\ncor\npower.t.test\n\n\n# Option 2: \n# S3 Methods\n# Some functions are generic and operate differently depending\n# on the class of the first argument\n# mean\n# print\n# summary\n\n#  Methods will list the actual function names called\nmethods(mean)\nmethods(print)\nmethods(summary)\n\nmean.default\nsummary.table\n\n\n# Option 3:\n# Some functions are part of packages but are not exported\n# I.e., they are intended for internal use, but\n# they are often quite useful\nlibrary(ProjectTemplate)\n\n# Double colon shows the functions exported from a package\n# i.e., packagename::function\nProjectTemplate::run.project\n    \n# Triple colon shows internal functions\n# i.e., packagename:::function\nProjectTemplate:::xls.reader\n\n# Also, see the getAnywhere function\nxls.reader # this doesn't work\ngetAnywhere(xls.reader) # this does work\n```\n\n\n# Exercise 4\n```{r Exercise 4}\nlibrary(MASS)\ndata(mammals)\n?mammals\nhead(mammals)\n# 1. Create a function that takes a single argument x\n#    and prints that value twice.\n#    use the function to print \"hello world\" twice\n\n\n# 2. Divide mammall brain weight (g) by body weight (kg) and \n#    get the mean of this value\n\n\n# 3. Write a function that takes arguments x and y\n#    and returns the mean of x divided by y\n\n\n# 4. Apply the function to get the mean ratio of brain to body size\n\n\n# 5. Modify the ratio function to return a list with \n#    (a) the mean of x divided by y, and\n#    (b) the sd of x divided by y. \n#    Then apply to mammals data as above.\n\n\n# 6. Step through the code for the correlation function \n\n\n# 7. Show the source code for \n#    (a) the t.test function, \n#    (b) the summary method for lm objects\n#    (c) the alpha function in the psych package\n\n```\n\n# Answers 4\n```{r Answers for Exercise 4}\nlibrary(MASS)\ndata(mammals)\n?mammals\nhead(mammals)\n# 1. Create a function that takes a single argument x\n#    and prints that value twice.\n#    use the function to print \"hello world\" twice\nprint_twice <- function(x) {\n    print(x)\n    print(x)\n}\nprint_twice(\"hello world\")\n\n\n# 2. Divide mammall brain weight (g) by body weight (kg) and \n#    get the mean of this value\nmean(mammals$brain / mammals$body )\n\n# 3. Write a function that takes arguments x and y\n#    and returns the mean of x divided by y\nmean_ratio <- function(x, y) {\n    mean(x / y)\n}\n\n# 4. Apply the function to get the mean ratio of brain to body size\nmean_ratio(mammals$brain, mammals$body)\n\n# 5. Modify the ratio function to return a list with \n#    (a) the mean of x divided by y, and\n#    (b) the sd of x divided by y. \n#    Then apply to mammals data as above.\nmean_ratio <- function(x, y) {\n    ratioxy <- x / y\n    list(mean_ratio = mean(ratioxy),\n         sd_ratio = sd(ratioxy))\n}\n\n# 6. Step through the code for the correlation function \n# debugonce(cor)\ncor(mammals$brain, mammals$body, method = \"spearman\")\n\n\n# 7. Show the source code for \n#    (a) the t.test function, \n#    (b) the summary method for lm objects\n#    (c) the alpha function in the psych package\n# t.test\n# summary.lm\n# psych::alpha\n```\n\n\n\n\n\n\n\n",
    "created" : 1467782236677.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "330824503",
    "id" : "24A0E789",
    "lastKnownWriteTime" : 1435037958,
    "path" : "~/teaching/r-training/training-materials/training-exercises/1-core-language.rmd",
    "project_path" : "1-core-language.rmd",
    "properties" : {
    },
    "relative_order" : 3,
    "source_on_save" : false,
    "type" : "r_markdown"
}